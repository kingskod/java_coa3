package com.voxelengine.render;

import com.voxelengine.world.Block;
import com.voxelengine.world.Chunk;

import java.util.Arrays;

public class GreedyMesher {

    // Custom primitive list to prevent Autoboxing (Float object creation)
    private static class FloatList {
        public float[] data = new float[4096];
        public int size = 0;

        public void add(float val) {
            if (size == data.length) {
                // Grow by 2x
                float[] newData = new float[data.length * 2];
                System.arraycopy(data, 0, newData, 0, data.length);
                data = newData;
            }
            data[size++] = val;
        }

        public float[] toArray() {
            return Arrays.copyOf(data, size);
        }
        
        public void clear() {
            size = 0;
        }
    }
    
    // Reuse this buffer to avoid allocation per chunk
    private final FloatList buffer = new FloatList();

    public Mesh generateMesh(Chunk chunk, TextureAtlas atlas) {
        buffer.clear();
        
        final int WIDTH = Chunk.WIDTH;
        final int HEIGHT = Chunk.HEIGHT;
        
        for (int d = 0; d < 3; d++) {
            int i, j, k, l, w, h;
            int u = (d + 1) % 3; 
            int v = (d + 2) % 3;
            int[] x = new int[3];
            int[] q = new int[3];
            
            int uMax = (u == 1 ? HEIGHT : WIDTH);
            int vMax = (v == 1 ? HEIGHT : WIDTH);
            boolean[] mask = new boolean[uMax * vMax];
            q[d] = 1; 
            
            int limit = (d == 1 ? HEIGHT : WIDTH);
            
            for (x[d] = -1; x[d] < limit; ) {
                int n = 0;
                // 1. Compute Mask
                for (x[v] = 0; x[v] < vMax; x[v]++) {
                    for (x[u] = 0; x[u] < uMax; x[u]++) {
                        Block b1 = (x[d] >= 0) ? chunk.getBlock(x[0], x[1], x[2]) : Block.AIR;
                        Block b2 = (x[d] < limit - 1) ? chunk.getBlock(x[0] + q[0], x[1] + q[1], x[2] + q[2]) : Block.AIR;
                        
                        boolean face1 = b1 != Block.AIR && b1.isSolid() && (b2 == Block.AIR || b2.isTransparent());
                        boolean face2 = b2 != Block.AIR && b2.isSolid() && (b1 == Block.AIR || b1.isTransparent());
                        
                        mask[n++] = face1 || face2;
                    }
                }
                
                x[d]++; 
                
                // 2. Greedy Generation
                n = 0;
                for (j = 0; j < vMax; j++) {
                    for (i = 0; i < uMax; ) {
                        if (mask[n]) {
                            int[] pos = new int[]{x[0], x[1], x[2]};
                            pos[d]--;
                            Block b1 = (pos[d] >= 0) ? chunk.getBlock(pos[0], pos[1], pos[2]) : Block.AIR;
                            pos[d]++;
                            Block b2 = (pos[d] < limit) ? chunk.getBlock(pos[0], pos[1], pos[2]) : Block.AIR;
                            
                            boolean face1 = b1 != Block.AIR && b1.isSolid() && (b2 == Block.AIR || b2.isTransparent());
                            Block currentBlock = face1 ? b1 : b2;
                            
                            int skyLight, blkLight;
                            if (face1) {
                                skyLight = chunk.getSkyLight(pos[0]-q[0], pos[1]-q[1], pos[2]-q[2]);
                                blkLight = chunk.getBlockLight(pos[0]-q[0], pos[1]-q[1], pos[2]-q[2]);
                            } else {
                                skyLight = chunk.getSkyLight(pos[0], pos[1], pos[2]);
                                blkLight = chunk.getBlockLight(pos[0], pos[1], pos[2]);
                            }

                            w = 1;
                            while (i + w < uMax && mask[n + w]) {
                                int[] checkPos = pos.clone();
                                checkPos[u] += w;
                                checkPos[d]--;
                                Block c1 = (checkPos[d] >= 0) ? chunk.getBlock(checkPos[0], checkPos[1], checkPos[2]) : Block.AIR;
                                checkPos[d]++;
                                Block c2 = (checkPos[d] < limit) ? chunk.getBlock(checkPos[0], checkPos[1], checkPos[2]) : Block.AIR;
                                
                                boolean cFace1 = c1 != Block.AIR && c1.isSolid() && (c2 == Block.AIR || c2.isTransparent());
                                Block cBlock = cFace1 ? c1 : c2;
                                
                                if (cFace1 != face1 || cBlock != currentBlock) break;
                                w++;
                            }
                            
                            h = 1;
                            boolean done = false;
                            while (j + h < vMax) {
                                for (k = 0; k < w; k++) {
                                    if (!mask[n + k + h * uMax]) { done = true; break; }
                                    
                                    int[] checkPos = pos.clone();
                                    checkPos[u] += k;
                                    checkPos[v] += h;
                                    checkPos[d]--;
                                    Block c1 = (checkPos[d] >= 0) ? chunk.getBlock(checkPos[0], checkPos[1], checkPos[2]) : Block.AIR;
                                    checkPos[d]++;
                                    Block c2 = (checkPos[d] < limit) ? chunk.getBlock(checkPos[0], checkPos[1], checkPos[2]) : Block.AIR;
                                    boolean cFace1 = c1 != Block.AIR && c1.isSolid() && (c2 == Block.AIR || c2.isTransparent());
                                    Block cBlock = cFace1 ? c1 : c2;
                                    
                                    if (cFace1 != face1 || cBlock != currentBlock) { done = true; break; }
                                }
                                if (done) break;
                                h++;
                            }
                            
                            float texIdx = atlas.getIndex(currentBlock.name().toLowerCase());
                            addQuad(d, i, j, w, h, x[d], face1, skyLight, blkLight, texIdx);
                            
                            for (l = 0; l < h; l++) {
                                for (k = 0; k < w; k++) {
                                    mask[n + k + l * uMax] = false;
                                }
                            }
                            i += w;
                            n += w;
                        } else {
                            i++;
                            n++;
                        }
                    }
                }
            }
        }
        
        return new Mesh(buffer.toArray());
    }

    private void addQuad(int d, int uPos, int vPos, int uSize, int vSize, int dPos, boolean backFace, int skyLight, int blkLight, float texIdx) {
        float[] v0 = new float[3];
        float[] v1 = new float[3];
        float[] v2 = new float[3];
        float[] v3 = new float[3];
        int u = (d + 1) % 3;
        int v = (d + 2) % 3;
        
        v0[d] = dPos; v0[u] = uPos;         v0[v] = vPos;
        v1[d] = dPos; v1[u] = uPos + uSize; v1[v] = vPos;
        v2[d] = dPos; v2[u] = uPos + uSize; v2[v] = vPos + vSize;
        v3[d] = dPos; v3[u] = uPos;         v3[v] = vPos + vSize;
        
        float uMin = 0; float uMax = uSize;
        float vMin = 0; float vMax = vSize;
        
        float sl = (float)skyLight / 15.0f;
        float bl = (float)blkLight / 15.0f;
        
        if (backFace) {
            addVert(v0, uMin, vMin, sl, bl, texIdx);
            addVert(v3, uMin, vMax, sl, bl, texIdx);
            addVert(v2, uMax, vMax, sl, bl, texIdx);
            addVert(v0, uMin, vMin, sl, bl, texIdx);
            addVert(v2, uMax, vMax, sl, bl, texIdx);
            addVert(v1, uMax, vMin, sl, bl, texIdx);
        } else {
            addVert(v0, uMin, vMin, sl, bl, texIdx);
            addVert(v1, uMax, vMin, sl, bl, texIdx);
            addVert(v2, uMax, vMax, sl, bl, texIdx);
            addVert(v0, uMin, vMin, sl, bl, texIdx);
            addVert(v2, uMax, vMax, sl, bl, texIdx);
            addVert(v3, uMin, vMax, sl, bl, texIdx);
        }
    }
    
    private void addVert(float[] pos, float u, float v, float sl, float bl, float tid) {
        buffer.add(pos[0]); buffer.add(pos[1]); buffer.add(pos[2]); 
        buffer.add(u); buffer.add(v); 
        buffer.add(sl); 
        buffer.add(bl); 
        buffer.add(tid); 
    }
}
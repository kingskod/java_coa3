package com.voxelengine.render;

import com.voxelengine.render.model.BlockModel;
import com.voxelengine.render.model.BakedModel;
import com.voxelengine.render.model.BakedQuad;
import com.voxelengine.render.model.BlockModel.QuadElement;
import com.voxelengine.utils.Direction;
import com.voxelengine.world.Block;

import java.util.ArrayList;
import java.util.List;

public class ModelRegistry {

    private static final BakedModel[][] CACHE = new BakedModel[256][16];
    private static TextureAtlas atlas;

    public static void init(TextureAtlas textureAtlas) {
        atlas = textureAtlas;

        for (Block block : Block.values()) {
            if (block == Block.AIR) continue;

            int id = block.getId() & 0xFF;

            for (int meta = 0; meta < 16; meta++) {
                BlockModel raw = getRawModel(block, (byte) meta);
                if (raw == null) {
                    CACHE[id][meta] = BakedModel.EMPTY;
                    continue;
                }

                CACHE[id][meta] = bake(raw);
            }
        }
    }

    private static BakedModel bake(BlockModel model) {
        List<BakedQuad> baked = new ArrayList<>();

        for (QuadElement q : model.getQuads()) {
            TextureAtlas.Sprite s = atlas.getSprite(q.texture);

            float[] uv = new float[8];
            for (int i = 0; i < 8; i += 2) {
                uv[i]     = s.uMin + q.uvs[i]     * (s.uMax - s.uMin);
                uv[i + 1] = s.vMin + q.uvs[i + 1] * (s.vMax - s.vMin);
            }

            baked.add(new BakedQuad(
                    q.positions,
                    uv,
                    q.face,
                    atlas.getIndex(q.texture, q.face),
                    -1
            ));
        }

        return new BakedModel(baked, true);
    }

    public static BakedModel getModel(Block block, byte meta) {
        int id = block.getId() & 0xFF;
        int m = meta & 15;
        return CACHE[id][m] != null ? CACHE[id][m] : BakedModel.EMPTY;
    }

    // ================= RAW MODEL DISPATCH =================

    private static BlockModel getRawModel(Block b, byte meta) {
        boolean active = b.isActive(meta);

        switch (b) {
            case LEVER:
                return active
                        ? GeneratedBlockModels.createLeverOn()
                        : GeneratedBlockModels.createLever();

            case REDSTONE_TORCH:
                return GeneratedBlockModels.createRedstoneTorch();

            case REDSTONE_TORCH_OFF:
                return GeneratedBlockModels.createRedstoneTorchOff();

            case AND_GATE:
                return active
                        ? GeneratedBlockModels.createAndGateBlockOn()
                        : GeneratedBlockModels.createAndGateBlock();

            case OR_GATE:
                return active
                        ? GeneratedBlockModels.createOrGateBlockOn()
                        : GeneratedBlockModels.createOrGateBlock();

            case NOT_GATE:
                return active
                        ? GeneratedBlockModels.createNotGateBlockOn()
                        : GeneratedBlockModels.createNotGateBlock();

            case NAND_GATE:
                return active
                        ? GeneratedBlockModels.createNandGateBlockOn()
                        : GeneratedBlockModels.createNandGateBlock();

            case REDSTONE_LAMP_OFF:
                return GeneratedBlockModels.createRedstoneLamp();

            case REDSTONE_LAMP_ON:
                return GeneratedBlockModels.createRedstoneLampOn();

            case STONE:
                return GeneratedBlockModels.createStone();

            case DIRT:
                return GeneratedBlockModels.createDirt();

            case GRASS:
                return GeneratedBlockModels.createGrassBlock();

            case COBBLESTONE:
                return GeneratedBlockModels.createCobblestone();

            case PLANKS:
                return GeneratedBlockModels.createOakPlanks();

            case BEDROCK:
                return GeneratedBlockModels.createBedrock();

            case GLASS:
                return GeneratedBlockModels.createGlass();

            case LOG:
                return GeneratedBlockModels.createOakLog();

            default:
                return null;
        }
    }
}

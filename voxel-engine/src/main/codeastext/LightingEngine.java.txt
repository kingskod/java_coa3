package com.voxelengine.world.light;

import com.voxelengine.world.Block;
import com.voxelengine.world.World;

import java.util.LinkedList;
import java.util.Queue;

public class LightingEngine {
    
    private final World world;
    
    // Separate queues to handle independent propagation
    private final Queue<LightNode> skyLightQueue = new LinkedList<>();
    private final Queue<LightNode> skyRemovalQueue = new LinkedList<>();
    
    private final Queue<LightNode> blockLightQueue = new LinkedList<>();
    private final Queue<LightNode> blockRemovalQueue = new LinkedList<>();

    public LightingEngine(World world) {
        this.world = world;
    }

    /**
     * Entry point for block updates (Place/Break).
     */
    public void updateBlock(int x, int y, int z) {
        Block block = world.getBlock(x, y, z);
        
        // 1. Handle Block Light (Torches, Glowstone)
        updateBlockLight(x, y, z, block);
        
        // 2. Handle Sky Light (Sun)
        updateSkyLight(x, y, z, block);
    }

    // =========================================
    // BLOCK LIGHT LOGIC (Standard Decay)
    // =========================================
    
    private void updateBlockLight(int x, int y, int z, Block block) {
        int oldLevel = world.getBlockLight(x, y, z);
        int newLevel = block.getLightLevel();

        if (newLevel > 0) {
            // Placed a light source
            world.setBlockLight(x, y, z, newLevel);
            blockLightQueue.add(new LightNode(x, y, z, newLevel));
            propagateBlockLight();
        } else if (oldLevel > 0) {
            // Removed a light source OR placed a solid block blocking light
            blockRemovalQueue.add(new LightNode(x, y, z, oldLevel));
            world.setBlockLight(x, y, z, 0);
            performBlockLightRemoval();
            
            // Re-propagate from neighbors to fill gaps
            checkNeighborsForRelight(x, y, z, false);
        } else if (!block.isTransparent()) {
            // Placed solid block in dark area (might block existing light flowing through)
            // We treat this as removing the light that WAS here (even if it was flow)
            // But we can't read the old flow because we just overwrote the block.
            // In a robust engine we read before set, but here we scan neighbors.
            checkNeighborsForRelight(x, y, z, false);
        } else {
            // Broke a block (Air) - Light flows IN
            checkNeighborsForRelight(x, y, z, false);
        }
    }
    /**
     * Scans the borders of a newly loaded chunk and its neighbors to propagate light across seams.
     */
    public void stitchChunkBorders(int chunkX, int chunkZ) {
        int cx = chunkX * 16;
        int cz = chunkZ * 16;

        // Check 4 boundaries: North (z-1), South (z+16), West (x-1), East (x+16)
        // We iterate the face (16 wide * 256 high) for each side.
        
        // 1. West Edge (x=0 local) <-> Neighbor East (x=15 local)
        stitchSeam(cx, cz, -1, 0, 0, 1, 16, 256);
        
        // 2. East Edge (x=15 local) <-> Neighbor West (x=0 local)
        stitchSeam(cx + 15, cz, 1, 0, 0, 1, 16, 256);
        
        // 3. North Edge (z=0 local) <-> Neighbor South (z=15 local)
        stitchSeam(cx, cz, 0, -1, 1, 0, 16, 256);
        
        // 4. South Edge (z=15 local) <-> Neighbor North (z=0 local)
        stitchSeam(cx, cz + 15, 0, 1, 1, 0, 16, 256);
        
        // Run the solvers
        propagateBlockLight();
        propagateSkyLight();
    }

    private void stitchSeam(int x, int z, int dx, int dz, int stepX, int stepZ, int length, int height) {
        // Iterate along the seam
        for (int l = 0; l < length; l++) {
            int curX = x + (l * stepX);
            int curZ = z + (l * stepZ);
            
            for (int y = 0; y < height; y++) {
                // Current Block (Inside new chunk)
                int mySky = world.getSkyLight(curX, y, curZ);
                int myBlk = world.getBlockLight(curX, y, curZ);
                
                // Neighbor Block (Outside)
                int nX = curX + dx;
                int nZ = curZ + dz;
                
                // If neighbor isn't loaded, getSkyLight returns default (15) or 0 depending on impl.
                // We must check if loaded to avoid polluting light with defaults.
                if (!world.isLoaded(nX, nZ)) continue;

                int nSky = world.getSkyLight(nX, y, nZ);
                int nBlk = world.getBlockLight(nX, y, nZ);
                
                // Logic: If neighbor is brighter, it flows into me.
                // If I am brighter, I flow into neighbor.
                
                // Sky Light Seam
                if (nSky > mySky + 1) {
                    world.setSkyLight(curX, y, curZ, nSky - 1);
                    skyLightQueue.add(new LightNode(curX, y, curZ, nSky - 1));
                } else if (mySky > nSky + 1) {
                    world.setSkyLight(nX, y, nZ, mySky - 1);
                    skyLightQueue.add(new LightNode(nX, y, nZ, mySky - 1));
                }
                
                // Block Light Seam
                if (nBlk > myBlk + 1) {
                    world.setBlockLight(curX, y, curZ, nBlk - 1);
                    blockLightQueue.add(new LightNode(curX, y, curZ, nBlk - 1));
                } else if (myBlk > nBlk + 1) {
                    world.setBlockLight(nX, y, nZ, myBlk - 1);
                    blockLightQueue.add(new LightNode(nX, y, nZ, myBlk - 1));
                }
            }
        }
    }

    private void performBlockLightRemoval() {
        while (!blockRemovalQueue.isEmpty()) {
            LightNode node = blockRemovalQueue.poll();
            int[][] dirs = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
            
            for (int[] d : dirs) {
                int nx = node.x + d[0];
                int ny = node.y + d[1];
                int nz = node.z + d[2];
                int neighborLevel = world.getBlockLight(nx, ny, nz);
                
                if (neighborLevel != 0 && neighborLevel < node.val) {
                    // It was lit by us (it is dimmer), so darken it
                    world.setBlockLight(nx, ny, nz, 0);
                    blockRemovalQueue.add(new LightNode(nx, ny, nz, neighborLevel));
                } else if (neighborLevel >= node.val) {
                    // It is a source or lit by another path. Add to propagation queue.
                    blockLightQueue.add(new LightNode(nx, ny, nz, neighborLevel));
                }
            }
        }
        propagateBlockLight();
    }

    private void propagateBlockLight() {
        while (!blockLightQueue.isEmpty()) {
            LightNode node = blockLightQueue.poll();
            
            int[][] dirs = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
            for (int[] d : dirs) {
                int nx = node.x + d[0];
                int ny = node.y + d[1];
                int nz = node.z + d[2];
                
                if (world.getBlock(nx, ny, nz).isTransparent()) {
                    int currentLevel = world.getBlockLight(nx, ny, nz);
                    if (currentLevel + 2 <= node.val) {
                        world.setBlockLight(nx, ny, nz, node.val - 1);
                        blockLightQueue.add(new LightNode(nx, ny, nz, node.val - 1));
                    }
                }
            }
        }
    }

    // =========================================
    // SKY LIGHT LOGIC (Vertical 15 Rule)
    // =========================================

    private void updateSkyLight(int x, int y, int z, Block block) {
        int oldLevel = world.getSkyLight(x, y, z);
        
        if (!block.isTransparent()) {
            // Placed solid block. It kills sky light here.
            if (oldLevel > 0) {
                skyRemovalQueue.add(new LightNode(x, y, z, oldLevel));
                world.setSkyLight(x, y, z, 0);
                performSkyLightRemoval();
            }
        } else {
            // Broke a block (Air). Light flows IN.
            // CRITICAL: Check directly above for Sunlight Rule
            int lightAbove = world.getSkyLight(x, y + 1, z);
            if (lightAbove == 15) {
                // We opened a hole to the sky/sunlight column
                world.setSkyLight(x, y, z, 15);
                skyLightQueue.add(new LightNode(x, y, z, 15));
                propagateSkyLight();
            } else {
                // Standard flow from neighbors
                checkNeighborsForRelight(x, y, z, true);
            }
        }
    }

    private void performSkyLightRemoval() {
        while (!skyRemovalQueue.isEmpty()) {
            LightNode node = skyRemovalQueue.poll();
            int[][] dirs = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
            
            for (int[] d : dirs) {
                int nx = node.x + d[0];
                int ny = node.y + d[1];
                int nz = node.z + d[2];
                int neighborLevel = world.getSkyLight(nx, ny, nz);
                
                if (neighborLevel == 0) continue;

                // Logic to determine if neighbor was lit by 'node'
                // Case A: Downward (Vertical Sunlight)
                // If we are passing light DOWN (d[1] == -1) and both are 15, it was lit by us.
                boolean verticalSun = (d[1] == -1 && node.val == 15 && neighborLevel == 15);
                
                // Case B: Standard Decay
                boolean standardDecay = (neighborLevel < node.val);

                if (verticalSun || standardDecay) {
                    world.setSkyLight(nx, ny, nz, 0);
                    skyRemovalQueue.add(new LightNode(nx, ny, nz, neighborLevel));
                } else {
                    // Neighbor sustains itself (source or other path). Re-propagate.
                    skyLightQueue.add(new LightNode(nx, ny, nz, neighborLevel));
                }
            }
        }
        propagateSkyLight();
    }

    private void propagateSkyLight() {
        while (!skyLightQueue.isEmpty()) {
            LightNode node = skyLightQueue.poll();
            int currentVal = node.val; // Use the value from queue or fetch fresh? Fresh is safer if updated.
            // Optimization: If world value changed since queue, skip?
            // For now, trust queue value, or fetch:
            // int currentVal = world.getSkyLight(node.x, node.y, node.z);
            
            int[][] dirs = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
            for (int[] d : dirs) {
                int nx = node.x + d[0];
                int ny = node.y + d[1];
                int nz = node.z + d[2];
                
                if (world.getBlock(nx, ny, nz).isTransparent()) {
                    int neighborLevel = world.getSkyLight(nx, ny, nz);
                    int expectedLevel = currentVal - 1;
                    
                    // SUNLIGHT RULE: Downwards propagation of 15 stays 15
                    if (d[1] == -1 && currentVal == 15) {
                        expectedLevel = 15;
                    }
                    
                    if (neighborLevel < expectedLevel) {
                        world.setSkyLight(nx, ny, nz, expectedLevel);
                        skyLightQueue.add(new LightNode(nx, ny, nz, expectedLevel));
                    }
                }
            }
        }
    }

    private void checkNeighborsForRelight(int x, int y, int z, boolean isSky) {
        int[][] dirs = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
        for (int[] d : dirs) {
            int nx = x + d[0];
            int ny = y + d[1];
            int nz = z + d[2];
            int level = isSky ? world.getSkyLight(nx, ny, nz) : world.getBlockLight(nx, ny, nz);
            if (level > 0) {
                if (isSky) skyLightQueue.add(new LightNode(nx, ny, nz, level));
                else blockLightQueue.add(new LightNode(nx, ny, nz, level));
            }
        }
        if (isSky) propagateSkyLight();
        else propagateBlockLight();
    }

    public void calculateInitialLighting(int chunkX, int chunkZ) {
        int cx = chunkX * 16;
        int cz = chunkZ * 16;
        
        // Initial Sky Light Pass (Top-Down)
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int light = 15;
                for (int y = 255; y >= 0; y--) {
                    int wx = cx + x;
                    int wz = cz + z;
                    Block b = world.getBlock(wx, y, wz);
                    if (!b.isTransparent()) {
                        light = 0;
                    } else if (light < 15 && light > 0) {
                        // If we are already decaying, continue decay
                        light--;
                    }
                    // Note: If light is 15 and block is transparent, it STAYS 15.
                    
                    world.setSkyLight(wx, y, wz, light);
                    if (light > 0) {
                        skyLightQueue.add(new LightNode(wx, y, wz, light));
                    }
                }
            }
        }
        propagateSkyLight();
    }

    private static class LightNode {
        int x, y, z, val;
        LightNode(int x, int y, int z, int val) {
            this.x = x; this.y = y; this.z = z; this.val = val;
        }
    }
}
package com.voxelengine;

import com.voxelengine.audio.SoundManager;
import com.voxelengine.core.GameLoop;
import com.voxelengine.core.Input;
import com.voxelengine.core.Window;
import com.voxelengine.entity.AABB;
import com.voxelengine.entity.EntityManager;
import com.voxelengine.entity.ItemEntity;
import com.voxelengine.entity.PhysicsEngine;
import com.voxelengine.entity.Player;
import com.voxelengine.logic.LogicSystem;
import com.voxelengine.render.Camera;
import com.voxelengine.render.Renderer;
import com.voxelengine.render.TextureAtlas;
import com.voxelengine.ui.Inventory;
import com.voxelengine.ui.ItemStack;
import com.voxelengine.ui.UIManager;
import com.voxelengine.utils.AssetGenerator;
import com.voxelengine.world.Block;
import com.voxelengine.world.World;
import org.joml.Vector3f;
import static org.lwjgl.glfw.GLFW.*;

public class Main {
    
    // UI State
    private static boolean inventoryOpen = false;
    private static boolean ePressed = false;

    public static void main(String[] args) {
        com.voxelengine.world.ChunkSerializer.WORLD_NAME = "world1"; 
        AssetGenerator.verifyAndGenerateAssets();
        Window window = new Window("Voxel Engine - " + com.voxelengine.world.ChunkSerializer.WORLD_NAME, 1280, 720);
        window.init();

        // Sound System
        SoundManager soundManager = new SoundManager();
        soundManager.loadSound("step.wav", "step.wav");
        soundManager.loadSound("break.wav", "break.wav");
        soundManager.loadSound("place.wav", "place.wav");
        soundManager.loadSound("splash.wav", "splash.wav");

        Camera camera = new Camera(window.getWidth(), window.getHeight());
        Renderer renderer = new Renderer();
        World world = new World();
        PhysicsEngine physics = new PhysicsEngine();
        Player player = new Player(0, 150, 0, camera, soundManager);
        EntityManager entityManager = new EntityManager();
        LogicSystem logic = new LogicSystem(world);
        Inventory inventory = new Inventory();
        UIManager uiManager = new UIManager(inventory, renderer.getTextureAtlas(), world, entityManager);

        final boolean[] mouseState = new boolean[2]; 

        GameLoop gameLoop = new GameLoop(window);
        gameLoop.setCallbacks(
            () -> {
                world.getChunkManager().update(player.getPosition());

                int px = (int) player.getPosition().x;
                int pz = (int) player.getPosition().z;
                if (!world.isLoaded(px, pz)) {
                    player.velocity.set(0, 0, 0); 
                    if (player.getPosition().y < 80) player.getPosition().y = 80;
                    return; 
                }

                // UI Input must be checked before game logic to pause it
                uiManager.handleInput();

                if (Input.isKeyDown(GLFW_KEY_E) && !uiManager.isChatOpen) {
                    if (!ePressed) {
                        uiManager.toggleInventory();
                        inventoryOpen = uiManager.isInventoryOpen;
                    }
                    ePressed = true;
                } else {
                    ePressed = false;
                }

                // If UI is open, skip player logic
                if (inventoryOpen || uiManager.isChatOpen) {
                     return;
                }

                world.tick();
                player.tick(world, physics, 1.0f / 60.0f);
                entityManager.tick(world, physics, 1.0f / 60.0f);
                player.checkPickups(entityManager, inventory);

                double scroll = Input.getScrollY();
                if (scroll != 0) inventory.scroll(scroll > 0 ? 1 : -1);
                
                boolean clickedLeft = Input.isMouseButtonDown(0);
                boolean clickedRight = Input.isMouseButtonDown(1);
                
                if (clickedLeft && !mouseState[0]) {
                    // Pass renderer.getTextureAtlas() here
                    raycast(world, camera, true, inventory, logic, entityManager, soundManager, renderer.getTextureAtlas());
                }
                if (clickedRight && !mouseState[1]) {
                    // Pass renderer.getTextureAtlas() here
                    raycast(world, camera, false, inventory, logic, entityManager, soundManager, renderer.getTextureAtlas());
                }
                
                mouseState[0] = clickedLeft;
                mouseState[1] = clickedRight;
            },
            () -> {
                org.lwjgl.opengl.GL11.glClear(org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT | org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT);
                if (window.isResized()) camera.updateProjection(window.getWidth(), window.getHeight());
                
                renderer.render(world, camera);
                entityManager.render(renderer);
                uiManager.render(window.getWidth(), window.getHeight());
            }
        );
        
        window.setMouseGrabbed(true);
        gameLoop.run();
        
        world.getChunkManager().saveAll();
        inventory.save();

        soundManager.cleanup();
        uiManager.cleanup();
        renderer.cleanup();
        window.cleanup();
    }
    
    // Updated signature to accept TextureAtlas
    private static void raycast(World world, Camera cam, boolean destroy, Inventory inventory, LogicSystem logic, EntityManager entityManager, SoundManager soundManager, TextureAtlas atlas) {
        Vector3f pos = cam.getPosition();
        Vector3f dir = new Vector3f();
        cam.getViewMatrix().positiveZ(dir).negate();
        
        // Raycasting Params
        float maxDist = 5.0f;
        
        // Store best hit
        float closestDist = maxDist;
        int hitX = 0, hitY = 0, hitZ = 0;
        int sideX = 0, sideY = 0, sideZ = 0; // The side we hit (for placement)
        boolean hitFound = false;

        // Efficient Voxel Traversal (DDA) or just stepped check?
        // Stepped check (0.05 step) is accurate enough for complex shapes
        
        // Optimization: We check blocks along the line.
        // For each block, we check exact AABB intersection.
        
        float step = 0.05f;
        Vector3f checkPos = new Vector3f();
        
        // Set of checked integer coordinates to avoid re-checking same block multiple times per step
        // (Simplified: just loop)
        
        for (float d = 0; d < maxDist; d += step) {
            checkPos.set(dir).mul(d).add(pos);
            
            int x = (int) Math.floor(checkPos.x);
            int y = (int) Math.floor(checkPos.y);
            int z = (int) Math.floor(checkPos.z);
            
            Block b = world.getBlock(x, y, z);
            if (b != Block.AIR && !b.isWater()) {
                // Check exact shape
                byte meta = world.getMetadata(x, y, z);
                AABB box = b.getSelectionBox(x, y, z, meta);
                if (box != null) {
                    // Offset box to world space for check
                    AABB worldBox = box.offset(x, y, z);
                    float dist = worldBox.rayIntersect(pos, dir);
                    
                    if (dist != -1.0f && dist < closestDist) {
                        closestDist = dist;
                        hitX = x; hitY = y; hitZ = z;
                        hitFound = true;
                        
                        // Determine face hit
                        // Move back slightly along ray
                        Vector3f hitPoint = new Vector3f(dir).mul(dist).add(pos);
                        // Simple face determination based on hit point relative to box center/edges?
                        // Or just step-back method (less accurate but easier):
                        Vector3f prev = new Vector3f(dir).mul(dist - 0.01f).add(pos);
                        sideX = (int)Math.floor(prev.x);
                        sideY = (int)Math.floor(prev.y);
                        sideZ = (int)Math.floor(prev.z);
                        
                        // Break early? No, we might hit a torch that is INSIDE the block bounds of air? 
                        // No, blocks grid. The first solid hit is the closest.
                        break; 
                    }
                }
            }
        }

        if (hitFound) {
            if (destroy) {
                Block b = world.getBlock(hitX, hitY, hitZ);
                if (b.getSoundType() != null) soundManager.play(b.getSoundType().breakSound);
                
                ItemStack drop = new ItemStack(b, 1);
                entityManager.addEntity(new ItemEntity(drop, hitX + 0.5f, hitY + 0.5f, hitZ + 0.5f, atlas));
                
                world.setBlock(hitX, hitY, hitZ, Block.AIR);
                logic.updateNetwork(hitX, hitY, hitZ); 
            } else {
                // Place
                ItemStack toPlace = inventory.getSelectedStack();
                if (toPlace.isEmpty()) return;
                
                // Prevent placing inside player (AABB check)
                // Use sideX/Y/Z calculated above
                // Note: The simple step-back method works for full cubes. 
                // For complex shapes, precise face normal is better, but this suffices for now.
                
                // Ensure target is replaceable or use offset
                // Logic: If we hit a block, we place against it (side coords).
                
                // Collision check against player
                AABB playerBox = new AABB(pos.x-0.3f, pos.y-1.5f, pos.z-0.3f, pos.x+0.3f, pos.y+0.3f, pos.z+0.3f);
                AABB blockBox = new AABB(sideX, sideY, sideZ, sideX+1, sideY+1, sideZ+1);
                
                if (!playerBox.intersects(blockBox)) {
                    if (toPlace.getBlock().getSoundType() != null) soundManager.play(toPlace.getBlock().getSoundType().placeSound);
                    
                    world.setBlock(sideX, sideY, sideZ, toPlace.getBlock());
                    inventory.useSelectedItem();
                    logic.updateNetwork(sideX, sideY, sideZ);
                }
                Block target = world.getBlock(hitX, hitY, hitZ);
                if (target == Block.LEVER) {
                // Toggle State (Meta Bit 2 is active)
                    byte meta = world.getMetadata(hitX, hitY, hitZ);
                    meta ^= 4; // Flip bit 2
                    world.setMetadata(hitX, hitY, hitZ, meta);
                    // Trigger updates
                    logic.updateNetwork(hitX, hitY, hitZ);
                    soundManager.play("lever.wav"); // If you have it
                    return; // Don't place a block if we flipped a lever
                }
            }
        }
    }
}
package com.voxelengine.world.gen;

import com.voxelengine.world.Block;
import com.voxelengine.world.Chunk;

import javax.imageio.ImageIO;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class TerrainGenerator {

    private static final int PREVIEW_SIZE = 1024;
    private final Noise noise;
    private final long seed;
    private final boolean[][] oceanMap; 

    public TerrainGenerator(long seed) {
        this.seed = seed;
        this.noise = new Noise(seed);
        this.oceanMap = generateOceanMap(); 
    }

    private boolean[][] generateOceanMap() {
        boolean[][] isOcean = new boolean[PREVIEW_SIZE][PREVIEW_SIZE];
        float[][] heightMap = new float[PREVIEW_SIZE][PREVIEW_SIZE];

        for (int x = 0; x < PREVIEW_SIZE; x++) {
            for (int z = 0; z < PREVIEW_SIZE; z++) {
                float n = (float) noise.noise(x * 0.005, 0, z * 0.005);
                heightMap[x][z] = (n + 1) / 2.0f; 
            }
        }

        float waterLevel = 0.4f;
        boolean[][] visited = new boolean[PREVIEW_SIZE][PREVIEW_SIZE];
        Random rng = new Random(seed);

        for (int x = 0; x < PREVIEW_SIZE; x++) {
            for (int z = 0; z < PREVIEW_SIZE; z++) {
                if (!visited[x][z] && heightMap[x][z] < waterLevel) {
                    Queue<Point> queue = new LinkedList<>();
                    LinkedList<Point> basin = new LinkedList<>();
                    queue.add(new Point(x, z));
                    visited[x][z] = true;

                    while (!queue.isEmpty()) {
                        Point p = queue.poll();
                        basin.add(p);

                        int[] dx = {1, -1, 0, 0};
                        int[] dz = {0, 0, 1, -1};

                        for (int i = 0; i < 4; i++) {
                            int nx = p.x + dx[i];
                            int nz = p.z + dz[i];
                            if (nx >= 0 && nx < PREVIEW_SIZE && nz >= 0 && nz < PREVIEW_SIZE) {
                                if (!visited[nx][nz] && heightMap[nx][nz] < waterLevel) {
                                    visited[nx][nz] = true;
                                    queue.add(new Point(nx, nz));
                                }
                            }
                        }
                    }

                    if (rng.nextFloat() < 0.60f) {
                        for (Point p : basin) {
                            isOcean[p.x][p.z] = true;
                        }
                    }
                }
            }
        }
        return isOcean;
    }

    public void generate(Chunk chunk) {
        int cx = chunk.chunkX * 16;
        int cz = chunk.chunkZ * 16;

        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int wx = cx + x;
                int wz = cz + z;

                int mapX = Math.abs(wx) % PREVIEW_SIZE;
                int mapZ = Math.abs(wz) % PREVIEW_SIZE;

                float n = (float) noise.noise(wx * 0.005, 0, wz * 0.005);
                float h = (n + 1) / 2.0f; 

                if (h > 0.8) {
                    h = 0.8f + (float) Math.pow((h - 0.8) * 5, 2) * 0.2f; 
                }

                int worldHeight = (int) (h * 128) + 64; 
                boolean isOcean = oceanMap[mapX][mapZ];
                
                boolean isBeach = false;
                if (!isOcean && h < 0.45) {
                    isBeach = true;
                }

                if (isOcean) {
                    worldHeight = (int)(h * 100); 
                }

                for (int y = 0; y < Chunk.HEIGHT; y++) {
                    if (y == 0) {
                        chunk.setBlock(x, y, z, Block.BEDROCK);
                    } else if (y < worldHeight - 4) {
                        chunk.setBlock(x, y, z, Block.STONE);
                    } 
                    // --- FIX IS HERE: Change 'worldHeight - 1' to 'worldHeight' ---
                    else if (y < worldHeight) { 
                        chunk.setBlock(x, y, z, isBeach || isOcean ? Block.SAND : Block.DIRT);
                    } 
                    // -------------------------------------------------------------
                    else if (y == worldHeight) {
                        if (isOcean) {
                            chunk.setBlock(x, y, z, Block.SAND);
                        } else if (isBeach) {
                            chunk.setBlock(x, y, z, Block.SAND);
                        } else {
                            chunk.setBlock(x, y, z, Block.GRASS);
                        }
                    } else if (y > worldHeight && y <= 60 && isOcean) {
                        chunk.setBlock(x, y, z, Block.WATER); 
                    }
                }
            }
        }
        chunk.isPopulated = true;
    }

    public void exportPreview(String path) {
        BufferedImage img = new BufferedImage(PREVIEW_SIZE, PREVIEW_SIZE, BufferedImage.TYPE_INT_RGB);
        for (int x = 0; x < PREVIEW_SIZE; x++) {
            for (int z = 0; z < PREVIEW_SIZE; z++) {
                if (oceanMap[x][z]) {
                    img.setRGB(x, z, Color.BLUE.getRGB());
                } else {
                    float n = (float) noise.noise(x * 0.005, 0, z * 0.005);
                    float h = (n + 1) / 2.0f;
                    int gray = (int)(h * 255);
                    if (h > 0.8) img.setRGB(x, z, Color.WHITE.getRGB()); 
                    else img.setRGB(x, z, new Color(gray, (int)(gray*1.2)%255, gray).getRGB());
                }
            }
        }
        try {
            File output = new File(path);
            output.getParentFile().mkdirs();
            ImageIO.write(img, "png", output);
            System.out.println("Exported worldgen preview to " + path);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static class Point {
        int x, z;
        Point(int x, int z) { this.x = x; this.z = z; }
    }
}